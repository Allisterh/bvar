\documentclass[article,nojss]{jss} % add nojss for vignette

%\VignetteIndexEntry{BVAR: Bayesian Vector Autoregressions with Hierarchical Prior Selection in R}
%\VignettePackage{BVAR}
%\VignetteKeyword{multivariate}
%\VignetteKeyword{time series}
%\VignetteKeyword{hierarchical}
%\VignetteKeyword{impulse responses}
%\VignetteKeyword{forecast}
%\VignetteKeyword{macroeconomics}





%% -- LaTeX packages and custom commands ---------------------------------------

%% recommended packages
\usepackage{thumbpdf,lmodern}

%% custom packages
\usepackage{float}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{natbib}
\usepackage{amsmath,amssymb}
\usepackage{placeins}

% number lines for now
% \usepackage{lineno}

% Color sections
\usepackage[usenames,dvipsnames]{xcolor}
\definecolor{teal1}{HTML}{008080}
\newcommand{\hteal}[1]{\colorbox{teal1!25}{$\displaystyle#1$}}
\newcommand{\htteal}[1]{\colorbox{teal1!25}{#1}}

%% new custom commands
\newcommand{\class}[1]{`\code{#1}'} % Hard-coded instead
\newcommand{\fct}[1]{\code{#1()}}


%% -- Article metainformation (author, title, ...) -----------------------------

%% - \author{} with primary affiliation
%% - \Plainauthor{} without affiliations
%% - Separate authors by \And or \AND (in \author) or by comma (in \Plainauthor).
%% - \AND starts a new line, \And does not.
\author{Nikolas Kuschnig \\ Vienna University of Economics and Business \And
        \And Lukas Vashold \\ Vienna University of Economics and Business}
\Plainauthor{Nikolas Kuschnig, Lukas Vashold}

%% - \title{} in title case
%% - \Plaintitle{} without LaTeX markup (if any)
%% - \Shorttitle{} with LaTeX markup (if any), used as running title
\title{\pkg{BVAR}: Bayesian Vector Autoregressions with Hierarchical Prior Selection in \proglang{R}}
\Plaintitle{BVAR: Bayesian Vector Autoregressions with Hierarchical Prior Selection in R}
\Shorttitle{\pkg{BVAR}: Hierarchical Bayesian VARs in \proglang{R}}

% \Volume{1}
% \Issue{1}
% \Month{1}
% \Year{1}
% \Submitdate{2019-06-30}
% \Acceptdate{1970-01-01}

%% - \Abstract{} almost as usual
\Abstract{
  Vector autoregression (VAR) models are widely used for multivariate time series analysis in macroeconomics, finance, and related fields. Bayesian methods are used to deal with their dense parameterization, imposing shrinkage on model coefficients via prior information. The optimal choice of the degree of informativeness implied by these priors is subject of much debate and can be approached via hierarchical modeling.
  This paper introduces \pkg{BVAR}, an \proglang{R} package dedicated to the estimation of Bayesian VAR models with hierarchical prior selection. It implements functionalities and options that permit addressing a wide range of research problems, while retaining an easy-to-use and transparent interface. Features include structural analysis of impulse responses, forecasts, some of the most commonly used conjugate priors, as well as a framework for defining custom dummy-observation priors.
  \pkg{BVAR} makes Bayesian VAR models user-friendly and provides an accessible, and reproducible, reference implementation.
}

%% - \Keywords{} with LaTeX markup, at least one required
%% - \Plainkeywords{} without LaTeX markup (if necessary)
%% - Should be comma-separated and in sentence case.
\Keywords{VAR, multivariate, time series, macroeconomics, econometrics, FRED-MD}
\Plainkeywords{VAR, multivariate, time series, macroeconomics, econometrics, FRED-MD}
%% - \Address{} of at least one author
%% - May contain multiple affiliations for each author
%%   (in extra lines, separated by \emph{and}\\).
%% - May contain multiple authors for the same affiliation
%%   (in the same first line, separated by comma).
\Address{
  Nikolas Kuschnig \\
  Vienna University of Economics and Business \\
  Institute for Ecological Economics \\
  Global Resource Use \\
  Welthandelsplatz 1 \\
  1020 Vienna, Austria \\
  E-mail: \email{nikolas.kuschnig@wu.ac.at} \\
  URL: \url{https://kuschnig.eu/}
}


\usepackage{Sweave}
\begin{document}
\input{img/fig-concordance}


%% -- Introduction -------------------------------------------------------------

%% - In principle "as usual".
%% - But should typically have some discussion of both _software_ and _methods_.
%% - Use \proglang{}, \pkg{}, and \code{} markup throughout the manuscript.
%% - If such markup is in (sub)section titles, a plain text version has to be
%%   added as well.
%% - All software mentioned should be properly \cite-d.
%% - All abbreviations should be introduced.
%% - Unless the expansions of abbreviations are proper names (like "Journal
%%   of Statistical Software" above) they should be in sentence case (like
%%   "generalized linear models" below).

% \linenumbers

\section{Introduction} \label{sec:intro}

% Introduce
Vector autoregression (VAR) models, popularized by \cite{sims1980}, have become a staple of empirical macroeconomic research \citep{kilian2017}. They are widely used for multivariate time series analysis and have been applied to evaluate DSGE models \citep{del2007}, investigate the effects of monetary policy \citep{bernanke2005, sims2006}, and conduct forecasting exercises \citep{litterman1986, koop2013}.
The large number of parameters and limited temporal availability of macroeconomic datasets often lead to over-parameterization problems \citep{koop2010} that can be circumvented by introducing prior information within a Bayesian approach. Informative priors are used to impose additional structure on the model and shrink it towards proven, parsimonious benchmarks. The result are models with reduced parameter uncertainty and significantly enhanced out-of-sample forecasting performance \citep{koop2013}. However, the specific choice and parameterization of these shrinkage priors pose a challenge that remains the fulcrum of discussion and critique.
A number of heuristics for prior selection have been proposed in the literature.
\cite{giannone2015} tackle this problem by setting prior informativeness in a data-based fashion, in the spirit of hierarchical modeling. Their flexible approach alleviates the subjectivity of setting prior parameters and acknowledges uncertainty surrounding these choices. The conjugate setup allows for efficient estimation and has been shown to perform remarkably well in common analyses \citep[see][]{miranda-agrippino2015, baumeister2016}.

% Provide background, narrow down domain
Amidst the rise of Markov chain Monte Carlo (MCMC) methods, Bayesian statistical software has evolved rapidly. Established software provides flexible and extensible tools for Bayesian inference and are available cross-platform. This includes \pkg{BUGS} \citep{lunn2000, lunn2009} and \pkg{JAGS} \citep{plummer2003}, which build on the Gibbs sampler, \pkg{Stan} \citep{carpenter2017}, which builds on Hamiltonian Monte Carlo, as well as \pkg{R-INLA} \citep{rue2015}, for approximate inference.
Domain-specific inference is facilitated by specialized packages, such as \pkg{MCMCglmm} \citep{hadfield2010} and \pkg{brms} \citep{burkner2018} for the \proglang{R} language \citep{R}.
In the domain of multivariate time series analysis, the \proglang{R} package \pkg{vars} \citep{pfaff2008} represents a cornerstone. It offers a comprehensive set of frequentist VAR-related functionalities, including the calculation and visualization of forecasts, impulse responses and forecast error variance decompositions. Other related packages include \pkg{MTS} \citep{tsay2018}, \pkg{BigVAR} \citep{nicholson2019}, and \pkg{tsDyn} \citep{dinarzo2020}, for a powerful and mature assortment of software.

% Bayesian VAR domain
Currently there exists no equivalent all-purpose tool for Bayesian VAR models in \proglang{R}. Applied work is often performed via ad hoc scripts, compromising reproducibility. Some \proglang{R} packages provide specialized implementations of Bayesian VAR models, but lack flexibility and accessibility.
The \pkg{bvarsv} package \citep{krueger2015} implements estimation of a model with time-varying parameters and stochastic volatility by \cite{primiceri2005}. Another approach is taken by \pkg{bvartools} \citep{mohr2019}, which provides functions to assist with Bayesian inference in VAR models, but does not include routines for estimation.
The \pkg{mfbvar} package by \cite{ankargren2019} implements estimation of mixed-frequency VAR models and provides forecasting routines. Several common prior distributions as well as stochastic volatility methods are available, but functions for structural analysis and inference are lacking.
Despite the popularity of Bayesian VAR models, there is a considerable gap between specialized Bayesian and accessible, all-purpose implementations.

% In comes BVAR
In this paper, we present \pkg{BVAR}, a comprehensive and user-friendly \proglang{R} package for the estimation and analysis of Bayesian VAR models. The package implements a hierarchical modeling approach to prior selection in the fashion of \cite{giannone2015}. Functionalities to facilitate most common analyses are provided. Standard methods and interfaces to existing frameworks ensure accessibility and extensibility. \pkg{BVAR} is free software, licensed under the GNU General Public License 3, is openly available and developed online.\footnote{See the Comprehensive \proglang{R} Archive Network (CRAN, \url{https://cran.r-project.org/package=BVAR}) and GitHub (\url{https://github.com/nk027/bvar}).}

The remainder of this paper is structured as follows. Section~\ref{sec:econ} describes the econometric framework of the package. Section~\ref{sec:bvar} provides an overview of the \pkg{BVAR} package, with the use demonstrated by means of an example in Section~\ref{sec:demo}. Section~\ref{sec:concl} concludes.


%% -- Manuscript ---------------------------------------------------------------

%% - In principle "as usual" again.
%% - When using equations (e.g., {equation}, {eqnarray}, {align}, etc.
%%   avoid empty lines before and after the equation (which would signal a new
%%   paragraph.
%% - When describing longer chunks of code that are _not_ meant for execution
%%   (e.g., a function synopsis or list of arguments), the environment {Code}
%%   is recommended. Alternatively, a plain {verbatim} can also be used.
%%   (For executed code see the next section.)

\section{Econometric framework} \label{sec:econ}

% Introduce econometric background
\pkg{BVAR} takes a Bayesian hierarchical modeling approach to VAR models. This section introduces the model, prior specification, and the hierarchical prior selection procedure proposed by \cite{giannone2015}. For further information on VAR models, the Bayesian approach to them, as well as Bayesian estimation and inference we refer the interested reader to \cite{kilian2017}, \cite{koop2010}, and \cite{gelman2013} respectively.

\subsection{Model specification} \label{subsec:model}

% About VARs
VAR models are a generalization of univariate autoregressive (AR) models, based on the notion of interdependencies between lagged values of all variables in a given model.
They are commonly resorted to as tools for investigating dynamic effects of shocks and perform well in forecasting exercises. A VAR model of finite order $p$, referred to as VAR($p$) model, can be expressed as:
\begin{align} \label{equ:var}
  \boldsymbol{y}_t = \boldsymbol{a}_0 + \boldsymbol{A}_1 \boldsymbol{y}_{t-1} + \dots + \boldsymbol{A}_p \boldsymbol{y}_{t-p} + \boldsymbol{\epsilon}_t,
  \text{ with }
  \boldsymbol{\epsilon}_t \sim \mathcal{N} (0, \boldsymbol{\Sigma}),
\end{align}
where $\boldsymbol{y}_t$ is an $M \times 1$ vector of endogenous variables, $\boldsymbol{a}_0$ is an $M \times 1$ intercept vector, $\boldsymbol{A}_j$ ($j = 1, \ldots, p$) are $M \times M$ coefficient matrices, and $\boldsymbol{\epsilon_t}$ is an $M \times 1$ vector of Gaussian exogenous shocks.
The number of coefficients to be estimated is $M + M^2 p$, rising quadratically with the number of included variables and linearly in the lag order.
This dense parameterization often leads to inaccuracies with regard to out-of-sample forecasting and structural inference, especially for higher-dimensional models. This phenomenon is commonly referred to as the curse of dimensionality.

% Bayesian VARs
The Bayesian approach to estimation of VAR models tackles this limitation by imposing additional structure on the model. Informative priors have been shown to be effective in mitigating the curse of dimensionality and allow for large models to be estimated \citep[see][]{banbura2010, doan1984}. They push model parameters towards a parsimonious benchmark, reducing estimation error and improving out-of-sample prediction accuracy \citep[see][]{koop2013}.
This shrinkage is related to frequentist regularization approaches \citep{hoerl1970, tibshirani1996}, which is discussed in detail by \cite{demol2008}, among others.
The flexibility of the Bayesian framework allows for accommodation of a wide range of economic issues, naturally involves prior information, and can account for layers of uncertainty through hierarchical modeling \citep{gelman2013}.

\subsection{Prior selection and specification} \label{subsec:prior}

% Introduce priors
Properly informing prior beliefs is critical and hence the subject of much research.
In the multivariate context, flat priors that attempt not to impose a certain belief, yield inadmissible estimators \citep{stein1956} and poor inference \citep{sims1980, banbura2010}. Other uninformative or informative priors are necessary. Early contributions \citep{litterman1980} set the priors and their parameters in a way that maximizes out-of-sample forecasting performance over a pre-sample. \cite{delnegro2004} choose values that maximize the marginal data density. \cite{banbura2010} use the in-sample fit as decision criterion and control for overfitting.
\cite{villani2009} reformulates the model and places priors on the steady state, which is better understood theoretically by economists. Economic theory is a preferred source of prior information, but is lacking in many settings -- in particular for high-dimensional models.

% Hierarchical approach
\cite{giannone2015} propose setting prior parameters in a data-based fashion, i.e., by treating them as additional parameters to be estimated. In their hierarchical approach, prior parameters are assigned their own hyperpriors with hyperparameters. Uncertainty surrounding the choice of prior parameters is acknowledged explicitly.
This can be expressed invoking Bayes' law as:
\begin{align}
  \label{equ:hm1}
  p(\boldsymbol{\gamma} | \boldsymbol{y}) & \propto \hteal{p(\boldsymbol{y} | \boldsymbol{\theta}, \boldsymbol{\gamma}) p(\boldsymbol{\theta} | \boldsymbol{\gamma})} ~ p(\boldsymbol{\gamma}),
  \\
  \label{equ:hm2}
  p(\boldsymbol{y} | \boldsymbol{\gamma}) & = \int \hteal{p(\boldsymbol{y} | \boldsymbol{\theta}, \boldsymbol{\gamma}) p(\boldsymbol{\theta} | \boldsymbol{\gamma})} d \boldsymbol{\theta},
\end{align}
where $\boldsymbol{y} = (\boldsymbol{y}_{p+1}, \ldots, \boldsymbol{y}_{T})^\top$, the autoregressive and variance parameters of the VAR model are denoted by $\boldsymbol{\theta}$, and the set of hyperparameters with $\boldsymbol{\gamma}$. The \htteal{highlighted} part of Equation~\ref{equ:hm1} is marginalized with respect to the parameters $\boldsymbol{\theta}$ in Equation~\ref{equ:hm2}. This yields a density of the data as a function of the hyperparameters $p(\boldsymbol{y} | \boldsymbol{\gamma})$, also called marginal likelihood (ML). This quantity is marginal with respect to the parameters, but conditional on the hyperparameters.
The ML can be used as a decision criterion for the hyperparameter choice; maximization constitutes an empirical Bayes method, with a clear frequentist interpretation \citep{giannone2015}.
In the Bayesian hierarchical approach, the ML is used to explore the full posterior hyperparameter space, acknowledging uncertainty surrounding them.

% Emphasise the hierarchical approach
The approach yields robust inference, is theoretically grounded, and can be implemented in an efficient manner \citep{giannone2015}. The authors demonstrate the high accuracy of impulse response functions and forecasts, with the model performing competitively compared to factor models. Since then, their approach has been used extensively in applied research \citep[see e.g.,][]{miranda-agrippino2015, baumeister2016, altavilla2018, nelson2018, altavilla2019}.

% Specific priors, introduce NIW
The contribution of \cite{giannone2015} focuses on conjugate prior distributions, specifically of the Normal-inverse-Wishart (NIW) family.\footnote{\cite{demol2008} note that this setting is similar to ridge penalized estimation in frequentist terms.}
Conjugacy implies that the ML is available in closed form, enabling efficient computation.
The NIW family includes some of the most commonly used priors \citep{koop2010, karlsson2013}, with some notable exceptions. These include the steady-state prior \citep{villani2009}, the Normal-Gamma prior \citep{griffin2010, huber2019}, and the Dirichlet-Laplace prior \citep{bhattacharya2015}.
Many recent contributions focus on accounting for heteroskedastic error structures \citep{clark2011, kastner2014, carriero2016}. This may improve model performance, but is not possible within the conjugate setup and would furthermore complicate inference.
In the chosen NIW framework we approach the model in Equation~\ref{equ:var} by letting $\boldsymbol{A} = \left[ \boldsymbol{a}_0, \boldsymbol{A}_1, \dots, \boldsymbol{A}_p \right]'$ and $\boldsymbol{\beta} = vec(\boldsymbol{A})$. Then:
\begin{align}
    \label{equ:niw}
    \boldsymbol{\beta} | \boldsymbol{\Sigma} &\sim \mathcal{N}(\boldsymbol{b}, \boldsymbol{\Sigma} \otimes \boldsymbol{\Omega}), \\
    \boldsymbol{\Sigma} &\sim \mathcal{IW} (\boldsymbol{\Psi}, \boldsymbol{d}), \nonumber
\end{align}
where $\boldsymbol{b}$, $\boldsymbol{\Omega}$, $\boldsymbol{\Psi}$ and $\boldsymbol{d}$ are functions of a lower-dimensional vector of hyperparameters $\boldsymbol{\gamma}$. In their paper, \cite{giannone2015} consider three specific priors -- the so-called Minnesota (Litterman) prior, which is used as a baseline, the sum-of-coefficients prior and the single-unit-root prior \citep[also see][]{sims1998}.

% Minnesota prior
The Minnesota prior \citep{litterman1980} imposes the hypothesis that individual variables all follow random walk processes. This parsimonious specification typically performs well in forecasts of macroeconomic time series \citep{kilian2017} and is often used as a benchmark to evaluate accuracy. The prior is characterized by the following moments:
\begin{align}
    \mathbb{E}[(\boldsymbol{A}_s)_{ij}|\boldsymbol{\Sigma}] &=
    \begin{cases}
        1 &\text{if } i=j \text{ and } s=1, \\
        0 &\text{otherwise}.
    \end{cases} \nonumber \\
    cov \left[(\boldsymbol{A}_s)_{ij}, (\boldsymbol{A}_r)_{kl} | \boldsymbol{\Sigma} \right] &=
    \begin{cases}
        \lambda^2 \frac{1}{s^\alpha} \frac{\boldsymbol{\Sigma}_{ik}}{\psi_j / (d-M-1)} &\text{if } l=j \text{ and } r=s, \\
        0 &\text{otherwise}. \nonumber
    \end{cases}
\end{align}
The key parameter $\lambda$ controls the tightness of the prior, i.e., it weighs the relative importance of prior and data. For $\lambda \to 0$ the prior outweighs any information in the data; the posterior will approach the prior. As $\lambda \to \infty$ the posterior expectations will approach the ordinary least squares estimates.
Governing the variance decay with increasing lag order, $\alpha$ controls the degree of shrinkage for more distant observations. Finally, $\psi_j$ controls the prior's standard deviation on lags of variables other than the dependent.

% Dummy priors
Refinements of the Minnesota prior are often implemented as additional priors trying to ``reduce the importance of the deterministic component implied by VAR models estimated conditioning on the initial observations'' \citep[p.~440]{giannone2015}. This component is defined as the expectation of future observations, given initial conditions and estimated coefficients.
The sum-of-coefficients prior \citep{doan1984} is one example for such an additional prior. It imposes the notion that a no-change forecast is optimal at the beginning of a time series. The prior can be implemented by adding artificial dummy-observations on top of the data matrix, which are constructed as follows:
\begin{align}
    \underset{M \times M}{\boldsymbol{y^+}} &= diag \left(\frac{\boldsymbol{\bar{y}}}{\mu}\right), \nonumber \\
    \underset{M \times (1 + Mp)}{\boldsymbol{x^+}} &= [\boldsymbol{0}, \boldsymbol{y^+}, \dots, \boldsymbol{y^+}], \nonumber
\end{align}
where $\boldsymbol{\bar{y}}$ is a $M \times 1$ vector of averages over the first $p$ -- $p$  denoting the lag order -- observations of each variable.
The key parameter $\mu$ controls the variance and hence the tightness of the prior. For $\mu \to \infty$ the prior becomes uninformative, while for $\mu \to 0$ the model is pulled towards a form with as many unit roots as variables and no cointegration.
The latter imposition motivates the single-unit-root prior \citep{sims1993, sims1998}, which allows for cointegration relationships in the data. The prior pushes the variables either towards their unconditional mean or towards the presence of at least one unit root. Its associated dummy observations are:
\begin{align}
    \underset{1 \times M}{\boldsymbol{y^{++}}} &= \frac{\boldsymbol{\bar{y}}}{\delta}, \nonumber \\
    \underset{1 \times (1 + Mp)}{\boldsymbol{x^{++}}} &= \left[\frac{1}{\delta}, \boldsymbol{y^{++}}, \dots, \boldsymbol{y^{++}}\right], \nonumber
\end{align}
where $\boldsymbol{\bar{y}}$ is again defined as above. Similarly to before, $\delta$ is the key parameter and governs the tightness of the prior.
The sum-of-coefficients and single-unit-root dummy-observation priors are commonly used in the estimation of VAR models in levels and fit the hierarchical approach to prior selection. Note however, that the approach is applicable to all priors from the NIW family in Equation~\ref{equ:niw}, yielding a flexible and readily extensible framework.


\section[The BVAR package]{The \pkg{BVAR} package} \label{sec:bvar}

% Introduce BVAR
\pkg{BVAR} implements a hierarchical approach to prior selection \citep{giannone2015} into \proglang{R} \citep{R} and hands the user an easy-to-use and flexible tool for Bayesian VAR models.
Its primary use cases are in the field of macroeconomic multivariate time series analysis. The hierarchical prior selection serves as a safeguard against unreasonable parameter choices. Due to its ease of use and flexible nature, \pkg{BVAR} is ideal for a broad range of economic analyses \citep[in the spirit of][]{baumeister2016, altavilla2018, nelson2018} and may be consulted as a reference for similar models.
The accessible and user-friendly implementation make it a suitable tool for introductions to multivariate time series modeling and the Bayesian paradigm.

% Mention some abstract features
The package is available cross-platform and on minimal installations, with no dependencies outside base \proglang{R} and \pkg{mvtnorm} \citep{genz2020}. It is implemented in native \proglang{R} for transparency and in order to lower the bar for contributions and/or adaptations.
A functional approach to the package structure facilitates optimization of computationally intensive steps, including ports to e.g., \proglang{C++}, and ensures extensibility. The complete documentation, helper functions to access the multitude of settings, and use of established methods for analysis make the package easy to operate, without sacrificing flexibility.

% Mention usage features
\pkg{BVAR} features extensive customization options with regard to priors to be employed, their parameters, and their hierarchical treatment. The Minnesota prior is used as baseline; all of its parameters are adjustable and can be treated hierarchically.
Users can easily include the sum-of-coefficients and single-unit-root priors of \cite{sims1998} and \cite{giannone2015}. The flexible implementation also allows users to construct custom dummy-observation priors.
Further options are devoted to the MCMC step and the Metropolis-Hastings (MH) algorithm that is used to explore the posterior hyperparameter space. The number of burned and saved draws are adjustable; thinning may be employed to reduce memory requirements and serial correlation. Proper exploration of the posterior is facilitated by options to manually scale individual proposals, or to enable automatic scaling until a target acceptance rate is achieved.
The customization options can be harnessed for flexible analysis with a number of established and specialized methods.

% Forecasts
A major function and common application of VAR models are predictions. VAR-based forecasts have proven to be superior to many other methods \citep{banbura2010, koop2013}. They do not rely on inducing particular restrictions on model parameters, as is the case for structural models. \pkg{BVAR} can be used to conduct both classic unconditional and conditional forecasts.
Unconditional forecasts are implemented to mirror base \proglang{R} for straightforward use. They rival those obtained from factor models in accuracy \citep{giannone2015} and can be used for a variety of analyses.
Conditional forecasts allow for elaborate scenario analyses, where the future path of one or more variables is assumed to be known. They are a handy tool for analyzing possible realizations of policy-relevant variables. The algorithmic implementation of conditional forecasts follows \cite{waggoner1999} and is closely linked to structural analysis.

% IRF
Impulse response functions (IRF) are a central tool for structural analysis. They provide insights into the behavior of economic systems and are another cornerstone of inference with VAR models.
IRF serve as a representation of shocks hitting the economic system and are used to analyze the reaction of individual variables. The exact propagation of these shocks is of great interest, but meaningful interpretation relies on proper identification.
\pkg{BVAR} features a framework for identification schemes, with two of the most popular schemes currently available -- namely short-term zero restrictions and sign restrictions. The former is also known as recursive identification and is achieved via Cholesky decomposition of the variance-covariance (VCOV) matrix $\boldsymbol{\Sigma}$ \citep[see][Chapter 8]{kilian2017}. This approach is computationally cheap and achieves exact identification without the need for detailed presumptions about variable behavior. Only the contemporaneous reactions of certain variables are limited, making the order of variables pivotal.
Sign restrictions \citep[see][Chapter 13]{kilian2017} are another popular means of identification that is implemented following the approach of \cite{rubio-ramirez2010}. This scheme requires some presumptions about the behavior of variables following a certain shock. With increasing dimension of the model theoretically grounding such presumptions becomes increasingly challenging. Additionally, identification via sign restrictions comes at the cost of increased uncertainty and a loss of precision for the resulting IRF.
Another related tool for structural analysis are forecast error variance decompositions (FEVD). FEVD are used to investigate which variables drive the paths of others after a shock. They can easily be computed in \pkg{BVAR} and allow for a more detailed structural analysis of the processes determining the behavior of an economic system.

% FRED datasets
\pkg{BVAR} packages the popular FRED-MD and FRED-QD databases \citep{mccracken2016}. They constitute two of the largest macroeconomic databases, featuring over 200 macroeconomic indicators on a monthly and a quarterly basis, respectively. They describe the US economy, starting from 1959 and are updated regularly.
The databases are distributed in \pkg{BVAR} under a permissive modified Open Data Commons Attribution License (ODC-BY 1.0).
Together with helper functions to aid with transformations, they allow users to start using the package hassle-free. FRED-MD and FRED-QD lend themselves to the study of a wide range of economic phenomena and are regularly used in benchmarking exercises for newly developed models and methods \citep[see inter alia][]{carriero2018, koop2019, huber2020}.

% Conclude
As detailed above, \pkg{BVAR} makes estimation of and inference in Bayesian VAR models accessible and user-friendly.
Extensive customization options are available, with sensible default settings allowing for a step-by-step adoption. This is further facilitated by lucid helper functions and comprehensive documentation.
Analysis of estimated VAR models is readily accessible -- functions for summarizing and plotting model parameters, forecasts, IRF, traces, densities, and residuals are available. Use of established procedures and standard methods, including \code{plot()}, \code{predict()}, \code{coef()}, and \code{summary()}, set a low barrier of entry for \proglang{R} users.
Final and intermediate outputs are provided in an idiomatic format and feature \code{print()} methods for quick access and a transparent research process.
Existing frameworks may be used for further analysis -- an interface to \pkg{coda} for checking outputs, analysis, and diagnostics is provided.
The available FRED-MD and FRED-QD datasets make \pkg{BVAR} an ideal tool for exploring a wide range of macroeconomic research questions.


%% -- Illustrations ------------------------------------------------------------

%% - Virtually all JSS manuscripts list source code along with the generated
%%   output. The style files provide dedicated environments for this.
%% - In R, the environments {Sinput} and {Soutput} - as produced by Sweave() or
%%   or knitr using the render_sweave() hook - are used (without the need to
%%   load Sweave.sty).
%% - Equivalently, {CodeInput} and {CodeOutput} can be used.
%% - The code input should use "the usual" command prompt in the respective
%%   software system.
%% - For R code, the prompt "R> " should be used with "+  " as the
%%   continuation prompt.
%% - Comments within the code chunks should be avoided - these should be made
%%   within the regular LaTeX text.

\section{An applied example} \label{sec:demo}

% Introduce the demonstration
In this section we demonstrate the functionalities of \pkg{BVAR} via an applied example. We use a subset of the included data and go through a typical workflow of (1) preparing the data, (2) configuring priors and other aspects of the model, (3) estimation of the model, and finally (4) analyzing outputs, including IRF and forecasts. Further possible applications and examples are available in the Appendix.
We start by setting a seed for reproducibility and loading \pkg{BVAR}.

\begin{Schunk}
\begin{Sinput}
R> set.seed(42)
R> library("BVAR")
\end{Sinput}
\end{Schunk}

\subsection{Data preparation} \label{subsec:data}

% Load and transform data
The main function \code{bvar()} expects input data to be coercible to a rectangular numeric matrix, i.e., without any missing values. For this example, we use six variables from the included FRED-QD dataset \citep{mccracken2016}, akin to the medium VAR considered by \cite{giannone2015}.
The six variables are real gross domestic product (GDP), real personal consumption expenditures, real gross private domestic investment (all three in billions of 2012 dollars), as well as the number of total hours worked in the non-farm business sector, the GDP deflator index as a means to measure price inflation, and the effective federal funds rate in percent per year. The covered time period ranges from Q1 1959 to Q3 2019.
We follow \cite{giannone2015} in transforming all variables except the federal funds rate to log-levels, in order to demonstrate aforementioned dummy priors.
Transformation can be performed manually or with the helper function \code{fred_transform()}. The function supports transformations listed by \cite{mccracken2016}, which can be accessed via their transformation codes. Additionally, suggested transformations from the FRED-QD and FRED-MD databases can be applied automatically or looked up via \code{fred_code()}. See Appendix~\ref{app:data} for a demonstration of this functionality.
For our example, we specify a log-transformation with code \code{4} for the corresponding variables and no transformation for the federal funds rate with code \code{1}.
Figure~\ref{fig:timeseries} provides an overview of the transformed time series.

\begin{Schunk}
\begin{Sinput}
R> data("fred_qd")
R> x <- fred_qd[, c("GDPC1", "PCECC96", "GPDIC1",
+    "HOANBS", "GDPCTPI", "FEDFUNDS")]
R> x <- fred_transform(x, codes = c(4, 4, 4, 4, 4, 1))
\end{Sinput}
\end{Schunk}


\begin{figure}[ht]
	\centering
  \includegraphics[width=0.9\textwidth]{img/fig-timeseries.pdf}
	\caption{Transformed time series under consideration.}
	\label{fig:timeseries}
\end{figure}

\subsection{Prior setup and further configuration} \label{subsec:setup}

% Introduce bv_
After preparing the data, we are ready to specify priors and configure our model.
Functions related to estimation setup and configuration share the prefix \code{bv_}. They are grouped in this way to make them easily discernible and their documentations accessible, facilitating their use.
This contrasts methods and functions for analysis, which stick closely to idiomatic \proglang{R}.
The goal of this naming scheme is to lower entry barriers for new users, while providing a comprehensive set of functionalities.

% Priors, start with Minnesota
Priors are set up using \code{bv_priors()}, which holds arguments for hierarchical treatment, the Minnesota, and dummy-observation priors.
We start by adjusting the Minnesota prior using \code{bv_minnesota()}. The prior parameter $\lambda$ has a Gamma hyperprior and is handed upper and lower bounds for its Gaussian proposal distribution in the MH step. For this example, we do not treat $\alpha$ hierarchically, meaning the parameter can be fixed via the \code{mode} argument. The prior variance on the constant term of the model (\code{var}) is dealt a large value, for a diffuse prior. We leave $\boldsymbol{\Psi}$ to be set automatically -- i.e., to the square root of the innovations variance, after fitting AR($p$) models to each of the variables.

\begin{Schunk}
\begin{Sinput}
R> mn <- bv_minnesota(
+    lambda = bv_lambda(mode = 0.2, sd = 0.4, min = 0.0001, max = 5),
+    alpha = bv_alpha(mode = 2), var = 1e07)
\end{Sinput}
\end{Schunk}

% Dummy priors
We also include the sum-of-coefficients and single-unit-root priors -- two pre-constructed dummy-observation priors. The hyperpriors of their key parameters are assigned Gamma distributions, with specification working in the same way as for $\lambda$. Custom dummy-observation priors can be set up similarly via \code{bv_dummy()} and require an additional function to construct the observations (see Appendix~\ref{app:dummy} for a demonstration).

\begin{Schunk}
\begin{Sinput}
R> soc <- bv_soc(mode = 1, sd = 1, min = 1e-04, max = 50)
R> sur <- bv_sur(mode = 1, sd = 1, min = 1e-04, max = 50)
\end{Sinput}
\end{Schunk}

% Wrap up priors
Once the priors are defined, we provide them to \code{bv_priors()}. The dummy-observation priors are captured by ellipsis argument (\code{...}) and need to be named. Via the argument \code{hyper} we choose which prior parameters should be treated hierarchically. Its default setting (\code{"auto"}) includes $\lambda$ and the key parameters of all provided dummy-observation priors. In our case, this is equivalent to providing the character vector \code{c("lambda", "soc", "sur")}. Prior parameters that are not treated hierarchically, e.g., $\alpha$ in this case, are treated as fixed and set equal to their \code{mode}.

\begin{Schunk}
\begin{Sinput}
R> priors <- bv_priors(hyper = "auto", mn = mn, soc = soc, sur = sur)
\end{Sinput}
\end{Schunk}

% Metropolis-Hastings
As a final step before estimation, we adjust the the MH algorithm via \code{bv_metropolis()}. The function allows us to fine-tune the exploration of the posterior space -- a vital prerequisite for proper inference.
The primary argument is \code{scale_hess}, a scalar or vector. It allows scaling the inverse Hessian, which is used as VCOV matrix of the Gaussian proposal distribution of the hierarchically treated hyperparameters. This affords us the flexibility of individually tweaking the posterior exploration of hyperparameters.
Scaling can be complemented by setting \code{adjust_acc = TRUE}, which enables automatic scale adjustment. This happens during an initial share of the burn-in period, adaptable via \code{adjust_burn}. Automatic adjustment is performed iteratively by \code{acc_change} percent, until an acceptance rate between \code{acc_lower} and \code{acc_upper} is reached.

\begin{Schunk}
\begin{Sinput}
R> mh <- bv_metropolis(scale_hess = c(1, 0.005, 0.005), adjust_acc = TRUE,
+    acc_lower = 0.25, acc_upper = 0.45, acc_change = 0.02)
\end{Sinput}
\end{Schunk}

% Wrap up setup
After configuring the model's priors and the MH step we are ready for estimation. Further available configuration options for the MCMC method, IRF, FEVD, and forecasts are described in the following paragraphs.
The available settings permit users to tailor models and specific components to their individual needs. This enables them to address an extensive set of research questions.
On the other hand, much simpler and quicker utilization is possible -- the default settings provide a suitable point of departure for many applications and the hierarchical approach brings additional parameter flexibility.
This enables users to (1) focus on critical parts of their model and (2) use \pkg{BVAR} with ease, facilitating gradual fine-tuning of models.

\subsection{Estimation of the model}

% Present estimation
Models are estimated using the core function \code{bvar()}.
As the bare minimum, we need to provide our prepared data and a lag order as arguments. Additionally, we pass on our customization objects from above to their respective arguments.
We also define the total number of iterations with \code{n_draw}, the number of initial iterations to discard with \code{n_burn}, and a denominator for the fraction of draws to store via \code{n_thin}. We increase the number of total and burnt iterations, while retaining all draws, since memory is not an issue in our example.
Note that arguments for computing IRF, FEVD and forecasts are also available and work similarly to the ex-post calculations that are demonstrated below.
When estimating the model, \code{verbose = TRUE} prompts printing of intermediate results and enables a progress bar during the MCMC step.

\begin{Schunk}
\begin{Sinput}
R> run <- bvar(x, lags = 5, n_draw = 50000, n_burn = 25000, n_thin = 1,
+    priors = priors, mh = mh, verbose = TRUE)