% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/81_parallel.R
\name{par_bvar}
\alias{par_bvar}
\title{Parallel Bayesian Vector Autoregression}
\usage{
par_bvar(
  cl,
  n_runs = length(cl),
  data,
  lags,
  n_draw = 10000L,
  n_burn = 5000L,
  n_save,
  n_thin = 1L,
  priors = bv_priors(),
  mh = bv_mh(),
  fcast = NULL,
  irf = NULL
)
}
\arguments{
\item{cl}{A \code{cluster} object obtained from
\code{\link[parallel]{makeCluster}}.}

\item{n_runs}{The number of parallel runs to calculate. Defaults to the
length of \emph{cl}, i.e. the number of registered nodes.}

\item{data}{Numeric matrix or dataframe. Note that observations need to be
ordered from earliest to latest one.}

\item{lags}{Integer scalar. Number of lags to apply to the data.}

\item{n_draw}{Integer scalar. Define the number of iterations
to (a) cycle through, (b) burn at the start, (c) save. Note that if provided
\emph{n_save} takes precedence over \emph{n_draw}.}

\item{n_burn}{Integer scalar. Define the number of iterations
to (a) cycle through, (b) burn at the start, (c) save. Note that if provided
\emph{n_save} takes precedence over \emph{n_draw}.}

\item{n_save}{Integer scalar. Define the number of iterations
to (a) cycle through, (b) burn at the start, (c) save. Note that if provided
\emph{n_save} takes precedence over \emph{n_draw}.}

\item{n_thin}{Integer scalar. Provides the option of reducing the number of
stored iterations to every \emph{n_thin}'th one. The number of saved
iterations thus equals \emph{(n_draw - n_burn) / n_thin}.}

\item{priors}{\code{bv_priors} object containing priors and their settings.
See \code{\link{bv_priors}}.}

\item{mh}{\code{bv_metropolis} object with settings regarding the acceptance
rate of the Metropolis-Hastings step. See \code{\link{bv_mh}}.}

\item{fcast}{\code{bv_fcast} object of forecast options set with
\code{\link{bv_fcast}}. May be set to \code{NULL} to skip forecasting.
Forecasts may also be calculated ex-post using \code{\link{predict.bvar}}.}

\item{irf}{\code{bv_irf} object with options regarding impulse responses and
forecast error variance decompositions. Set via \code{\link{bv_irf}} or
skipped when set to \code{NULL}. May also be computed ex-post using
\code{\link{irf.bvar}}.}
}
\description{
Wrapper to speed up parallel computation using
\code{\link[parallel]{parLapply}}. Make sure to properly start and stop the
provided cluster.
}
\examples{
\donttest{
library("parallel")

cl <- makeCluster(2L)
data <- matrix(rnorm(200), ncol = 2)

# A singular run
x <- bvar(data, lags = 2)
# Two parallel runs
y <- par_bvar(cl, n_runs = 2, data = data, lags = 2)

stopCluster(cl)

# Plot lambda for all of the runs
plot(x, type = "full", vars = "lambda", chains = y)
}
}
\seealso{
\code{\link{bvar}}; \code{\link[parallel]{parLapply}}
}
\keyword{BVAR}
\keyword{VAR}
\keyword{mcmc}
\keyword{parallel}
